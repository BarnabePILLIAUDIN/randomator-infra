name: Deploy

on: 
  # push:
  #   branches: 
  #     - main
  workflow_dispatch: 

jobs:
  deploy-aks-cluster:
    defaults:
      run:
        working-directory: ./terraform/azure
    runs-on: ubuntu-latest
    outputs:
      kubectl_command: ${{ steps.tf-outputs.outputs.kubectl_command }}
    environment: ci
    env:
      # Terraform variables passed to the config (kept for backward compatibility)
      TF_VAR_azure_subscription_id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      TF_VAR_azure_tenant_id: ${{ secrets.AZURE_TENANT_ID }}
      TF_VAR_azure_client_id: ${{ secrets.AZURE_CLIENT_ID}}
      TF_VAR_azure_client_secret: ${{ secrets.AZURE_CLIENT_SECRET}}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
    steps:
      - uses: actions/checkout@v5
      - uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: 1.6.0
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      - name: Tofu init (Azure backend)
        run: |
          tofu init \
          -backend-config="storage_account_name=${{ vars.AZURE_BACKEND_STORAGE_ACCOUNT }}" \
          -backend-config="container_name=${{ vars.AZURE_BACKEND_STORAGE_CONTAINER }}" \
          -backend-config="key=terraform.tfstate" \
          -backend-config="resource_group_name=${{ vars.AZURE_BACKEND_RESOURCE_GROUP }}" \
          -backend-config="subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
          -backend-config="tenant_id=${{ secrets.AZURE_TENANT_ID }}"
      - name: Tofu validate
        run: tofu validate
      - name: Tofu apply
        run: tofu apply --auto-approve
      - name: Capture kubectl command output
        id: tf-outputs
        run: |
          echo "kubectl_command=$(tofu output -raw kubectl_config_command)" >> $GITHUB_OUTPUT

  deploy-apps:
    needs: deploy-aks-cluster
    runs-on: ubuntu-latest
    environment: ci
    steps:
      - uses: actions/checkout@v5
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.27.3'
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      - name: Configure kubeconfig
        run: |
          set -euo pipefail
          cmd="${{ needs.deploy-aks-cluster.outputs.kubectl_command }}"
          if [ -z "$cmd" ]; then
            echo "kubectl_command is empty" >&2
            exit 1
          fi
          # Execute the command produced by Terraform to populate the kubeconfig
          eval "$cmd"
      - name: Setup Helm
        uses: azure/setup-helm@v4.3.0
      - name: Create auth secrets and ns
        run: |
          for ns in randomator-staging randomator-prod; do
            kubectl create ns $ns --dry-run=client -o yaml| kubectl apply -f -
            kubectl create secret docker-registry docker-auth \
              --docker-server="${{secrets.REGISTRY_URL}}" \
              --docker-username="${{secrets.REGISTRY_USERNAME}}" \
              --docker-password="${{secrets.REGISTRY_TOKEN}}" \
              --docker-email="${{secrets.REGISTRY_EMAIL}}" \
              -n $ns \
              --dry-run=client -o yaml| kubectl apply -f - 
          done
      - name: Setup Cert Manager
        run: |
          helm upgrade --install cert-manager oci://quay.io/jetstack/charts/cert-manager \
            --version v1.19.1 \
            --namespace cert-manager \
            --create-namespace \
            --atomic \
            --set crds.enabled=true
      - name: Apply Cluster issuer
        run: kubectl apply -f cert-manager/lets-encrypt-issuer.yaml
      - name: Setup ingress controller
        run: |
          helm upgrade --install ingress-nginx ingress-nginx \
            --repo https://kubernetes.github.io/ingress-nginx \
            --namespace ingress-nginx --create-namespace --atomic
      - name: Install Crossplane
        run: |
          curl -sL "https://cli.upbound.io" | sh
          sudo mv up /usr/local/bin/
          up uxp install
          helm repo add crossplane-stable https://charts.crossplane.io/stable
          helm repo update
          helm upgrade --install crossplane \
            --namespace crossplane-system \
            --create-namespace crossplane-stable/crossplane \
            --set crds.enabled=true \
            --create-namespace --atomic
      - name: Install scaleway provider
        run: kubectl apply -f crossplane/scaleway-provider.yaml
        
      - name: Wait for CRDs to be installed
        run: |
          set -euo pipefail
          echo "Waiting for CRDs to appear..."
          # wait until at least one CRD is present
          until kubectl get crd --no-headers 2>/dev/null | grep -q .; do
            echo "No CRDs detected yet, sleeping 3s..."
            sleep 3
          done
          echo "CRDs detected, waiting for them to become Established (timeout 300s)..."
          # wait for all CRDs to become Established (timeout can be adjusted)
          kubectl wait --for=condition=Established --all crd --timeout=300s
      - name: Create SCW auth secret
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Secret
          metadata:
            name: scaleway-auth
            namespace: crossplane-system
          type: Opaque
          stringData:
            credentials: |
              {
                "access_key": "${{secrets.SCW_ACCESS_KEY}}",
                "secret_key": "${{secrets.SCW_SECRET_KEY}}",
                "project_id": "${{secrets.SCW_PROJECT_ID}}",
                "region": "fr-par",
                "zone": "fr-par-1"
              }
          EOF
      - name: Link scw provider to scw auth
        run: kubectl apply -f crossplane/provider-config.yaml
      - name: Create DNS record
        run: |
          sudo apt install jq
          IP=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}{"\n"}')
          cat <<EOF | kubectl apply -f -
              apiVersion: domain.scaleway.upbound.io/v1alpha1
              kind: Record
              metadata:
                name: domain-record-prod-front
              spec:
                forProvider:
                  dnsZone: ${{secrets.SCW_DOMAIN}}
                  type: A
                  data: $IP
                  ttl: 60
                  priority: 0
                  name: prod-front
                providerConfigRef:
                  name: default
            EOF
          cat <<EOF | kubectl apply -f -
              apiVersion: domain.scaleway.upbound.io/v1alpha1
              kind: Record
              metadata:
                name: domain-record-prod-back
              spec:
                forProvider:
                  dnsZone: ${{secrets.SCW_DOMAIN}}
                  type: A
                  data: $IP
                  ttl: 60
                  priority: 0
                  name: prod-back
                providerConfigRef:
                  name: default
            EOF
            cat <<EOF | kubectl apply -f -
              apiVersion: domain.scaleway.upbound.io/v1alpha1
              kind: Record
              metadata:
                name: domain-record-staging-front
              spec:
                forProvider:
                  dnsZone: ${{secrets.SCW_DOMAIN}}
                  type: A
                  data: $IP
                  ttl: 60
                  priority: 0
                  name: staging-front
                providerConfigRef:
                  name: default
            EOF
          cat <<EOF | kubectl apply -f -
              apiVersion: domain.scaleway.upbound.io/v1alpha1
              kind: Record
              metadata:
                name: domain-record-staging-back
              spec:
                forProvider:
                  dnsZone: ${{secrets.SCW_DOMAIN}}
                  type: A
                  data: $IP
                  ttl: 60
                  priority: 0
                  name: staging-back
                providerConfigRef:
                  name: default
            EOF
      - name: Install argoCD
        run: |
          helm repo add argo https://argoproj.github.io/argo-helm
          helm repo update
          helm upgrade --install argocd argo/argo-cd \
            --values argocd/values.yaml \
            --namespace argocd \
            --atomic \
            --create-namespace
      - name: Create ArgoCD apps
        run: |
          kubectl apply -f argocd/randomator-project.yaml
          kubectl apply -f argocd/staging-app.yaml
          kubectl apply -f argocd/prod-app.yaml
